# XSS Basics

These vulnerabilities arise when the user input is not properly sanitized and allows to write JS code to the page and execute it on the client side.

A web app receives HTML code from the backend and renders it on the browser. 

When the app doesn't properly sanitize this input, the attacker can inject JS code in an input field.

XSS vulnerabilities are executed on the client-side and don't directly affect the backend, only the user executing the vulnerbility.

**XSS Attacks**

A basic example is having the target user send their session cookie to the attacker's web server.

Another example is having the target's browser execute API calls that lead to malicious actions, such as changing the password.

Types of XSS:
- Stored XSS - Is the most critical, happens when user input is stored on the database and displayed upon retrieval.
- Reflected - Happens when the user input is displayed on hte page after being processed by the backend server.
- DOM-based - Also non-persistent, and occurs when user input is directly shown in the browser and is completely processed on the client side.

## Stored XSS

This is most critical because it affects a wider audience, because any user who visits the page, would be a victim of this attack.

An example would be a webpage that offers to option to create a **to do list**, so when we write something, the input is reflected back to us.

If we put `<script>alert(window.origin)</script>` and refresh it, it would display an alert showing the url of the page it is being executed on.

Some modern browsers can block `alert()` function in some locations, so maybe other payloads should be tried, such as `<script>print()</script> which pops up the browser print dialog.


## Reflected XSS

This non-persistent vulnerability, gets processed by the backend server.

It occurs when the input reaches the backend and gets returned to us without being filtered.

An example of **Reflected XSS** can be the similar **To do webpage**, andfor example when we want to add a *to do task*, it shows an error stating:

`Task 'test' could not be added` 

This means that our input is being reflected, but it's a simple error message, and it will be removed as soon as the page is refreshed.

**Since non-persistent, how can victims be targeted**

First we check when we put that *to do task* what kind of HTTP request is it.

If it's a `GET`, it means that it sends their parameters and data as part of the URL, so to target the user, we should send them a URL containing the payload.

## DOM XSS

This vulnerability is completely processed on the client-side, and it occurs when JS is used to change the page source through the **Document Object Model**.


If we use the same **to do webpage** for an example, let's say that we put a new task in there, and then open the *Network* tab in Firefox, and re-add the item, we see that there are not HTTP requests being made.

We see the input parameter in the URL is a hashtag `#` for the item we added, meaning that this is a client-side parameter completely processed on the browser.

**Source and Sink**
The *Source* is the JS object that takes hte user input, and *Sink* is the function that writes the user input to a DOM Object on the page.

If the Sink doesn't sanitize the input, it would be vulnerable to XSS attack.

Common functions to write to DOM:
- document.write()
- DOM.innerHTML
- DOM.outerHTML

jQuery functions that write to DOM objects:
- add()
- after()
- append()

If we take a look at the `scipt.js` we see that the *Source* is being taken from the `task=` parameter:

```js
var pos = document.URL.indexOf("task=");
var task = document.URL.substring(pos + 5, document.URL.length);
```

We see also that it uses hte `innerHTML` function to write the task in the `todo` DOM:

```js
document.getElementById("todo").innerHTML = "<b>Next Task:</b> " + decodeURIComponent(task);
```

Meaning we control the input, and the output is not sanitized.

**Attack**
If we try the payload as before on reflected and stored, it will not be executed, as `innerHTML` doesn't allow the `<script>` tags as a security feature.

But the one below works:

`<img src="" onerror=alert(window.origin)>`

This creates anew HTML image object, wattirbute that can execute JS code when the image is not found.

## XSS Discovery

Almost every App vulnerability scanner (Nessus, Burp Pro, ZAP) can detect XSS, and they offer a **passive scan** which reviews client-side code for potential DOM XSS, and **active scan** which sends payloads to trigger an XSS.

Some common open-source tools:
- XSS Strike
- Brute XSS
- XSSer

**XSS Strike**
```sh
git clone https://github.com/s0md3v/XSStrike.git
cd XSStrike
pip install -r requirements.txt
python xsstrike.py -u "http://server:port"
```

The most reliable way of detecting XSS is manual code review, and if we understand how the input is being handled we can write a custom payload.

