# XSS Prevention

These vulnerabilities are mainly linked to two parts of the web app:
- Source - a user input field
- Sink - displays the input data.

So these should be secured - input sanitization and validation on both front and backend.

## Front-end

**Input Validation**
For example the email field shouldn't allow incorrect email formats, as an example this can be done with the following JS code:

```js
function validateEmail(email) {
    const re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test($("#login input[name=email]").val());
}
```

**Input Sanitization**
Don't allow any input with JS code in it - escaping any special characters.

For this `DOMPurify`, a JS library, can be used:

```js
<script type="text/javascript" src="dist/purify.min.js"></script>
let clean = DOMPurify.sanitize( dirty );
```

This escapes any special characters with a backslash `\`.

**Direct Input**
Never use user input directly withing certain HTML tags:
- JS code `<script></script>`
- CSS Style Code `<style></style>`
- Tag/Attribute Fields `<div name='INPUT'></div>`
- HTML Comments `<!-- -->`

## Back-end
Securing Backend in order to prevent Stored and Reflected XSS vulnerabilities.

**Input Validation**
Quite similar to the front-end. For example e-mail validation on a PHP backend:

```php
if (filter_var($_GET['email'], FILTER_VALIDATE_EMAIL)) {
    // do task
} else {
    // reject input - do not display it
}
```

**Input Sanitization**
Here backend plays a vital role, because the frontend sanitization can be bypassed by sending custom `GET/POST` requests.

PHP backend can use `addslashes` function to sanitize user input by escaping characters with a backslash:

```php
addslashes($_GET['email'])
```

**Output HTML Encoding**
We have to encode any special characters into their HTML codes - helpful if we need to display the entire user input without having a XSS vulnerability.

For a php backend `htmlspecialchars` or `htmlentities` can be used which encode special characters into their HTML codes:

```php
htmlentities($_GET['email']);
```

**Server Configuration**
- HTTPS across entire domain
- XSS prevention headers
- Appropriate `Content-Type` for the page, like `X-Content-Type-Options=nosniff`.
- Use `Content-Security-Policy` options, like `script-src 'self'` - allows only locally hosted scripts.
- Use `HttpOnly` and `Secure` cookie flags to prevent JS from reading cookies and only transport them over HTTPS.

