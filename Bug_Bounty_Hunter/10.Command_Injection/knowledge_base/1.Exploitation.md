# Introduction

Is among the most critical ones.

Allows to execute system commands directly on the backend - compromises the entire network.

It occurs when a web app uses user-controlled input to execute a system command on the backend to retrieve and return some output.

Types:
- OS Command Injection
- Code Injection
- SQL Injection
- Cross-Site Scripting/HTML Injection

There are also other types such as LDAP injection, HTTP header injection, etc.

**OS Command Injection PHP Example**

```sh
<?php
if (isset($_GET['filename'])) {
    system("touch /tmp/" . $_GET['filename'] . ".pdf");
}
?>
```

This is a part of the code on a web app that allows users to create a new `.pdf` file on the `/tmp` directory.

But the user input of the `filename` parameter is used directly with the `touch` command, without being sanitized, leads to OS command injection.

# Detection & Injection Methods

For these vulnerabilities the process of detection is the same as of the exploitation.

Injecting additional commands to the intended one, can be by using the following:

|Character|Executed Command|
|-|-|
|;|both|
|\n|both|
|&|Both(second shown first)|
|(pipe)|Both(Only second shown)|
|&&|Both(only if first succeeds)|
|OR|Second(Only if first fails)|
|Subshell ``|Both(Linux only)|
|Subshell $()|Both(Linux only)|

# Injecting Commands

From the first lab we got an error saying to put the text in the required format.

But, if we check the `Developer Tools` under Network Tab, when we click on `Check` button, we don't see any network requests being made.

This indicates that the input validation is happening on the front-end.

We can easily bypass this, for example by using `Burp`, sending a working request to the `Repeater`, and then just changing the body, and resending the request.


