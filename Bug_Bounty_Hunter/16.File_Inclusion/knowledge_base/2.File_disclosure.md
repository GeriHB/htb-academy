# File Disclosure

## Local File Inclusion

If the vulnerability exists we may read a file by specifying its absolute path.

For example on the following ip address:

`http://<SERVER_IP>:<PORT>/index.php?language=es.php`

We see that the language set here is `Spanish` and this url changed after we selected this language.

So, this means, it's reading a file `es.php`.

And here we can put a file that we want to read, for example `/etc/passwd`

`http://<SERVER_IP>:<PORT>/index.php?language=/etc/passwd`

### Path Traversal

The example above works if the whole input was used within the `include()` function, without any additions:

```php
include($_GET['language']);
```

But, this rarely happens, as devs append or prepend a string, for example `language` parameter can be used for a filename, and `languages` a directory in which the file is:

```php
include("./languages/" . $_GET['language']);
```

So, now if we put the whole path like in the example above, it would make it `./languages/etc/passwd` so it would be invalid.

But this can easily be bypassed by what is known as `path traversal`, so we will be using **relative paths**, and use the `../` to go to the parent directory.

And now this would work:
`http://<SERVER_IP>:<PORT>/index.php?language=../../../../etc/passwd`

If we are unsure how many `../` to put, we can add as much as we want, because even if we are in the `root` directory, doing a `../` would point to the root directory again.

### Filename Prefix

Sometimes there exists a filename prefix, which is added to the file that is accessed. For example:

```php
include("lang_", $_GET['language']);
```

And tin this case if we want to access `../../../etc/passwd` it will be `lang_../../../etc/passwd`, which makes it invalid

A way to bypass this is to include a `/` in the beginning of the filename that we want to access, which makes it `lang_/../../../etc/passwd`.

This only works if there is a directory `lang_` in the folder.

### Appended Extensions

A common example is when an extension is appended to the parameted:

```php
include($_GET['language'] . ".php");
```

So, whenever you want to access a file it will append the `php` extension in the end.

For example trying to access `/etc/passwd/` will make it `/etc/passwd.php` which is invalid.

### Second-Order Attacks

Occurs when a web app functionality insecurely pulls files from the backend server based on user-controlled parameters.

An example would be when a web app allows us to download the avatar `/avatar.png` and if we craft a malicious username like `../../../etc/passwd` we can grab it instead of the avatar.

This would poison the database with the payload in our username, and another app functionality would utilize this payload to perform the attack (download the avatar).

This is why it's called `Second-Order` attack.

## Basic Bypasses

### Non-Recursive Path Traversal Filters

One of the basic filters is to delete `../` substrings in order to avoid path traversals:

```php
$language = str_replace('../', ''. $_GET['language']);
```

This is quite insecure, because it doesn't remove recursively the `../` substring. 

It just runs a single time on the input and doesn't apply the filter on the output string.

So we can easily bypass this for example by putting `....//` and the filter would remove a `../` making it `../` as we want.

### Encoding

A better protection is by preventing characters like a `.` or `/` which are used for path traversal.

This can still be easily bypassed, by `url-encoding` the malicious string, which would remove all the `.` and `/`.

For example `../` would become `%2e%2e%2f`.

### Approved Paths

Some web apps may use Regular Expressions to make sure that the file is under a specific path, like for example under the `./languages` directory:

```php
if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
    include($_GET['language']);
} else {
    echo 'Illegal path specified!';
}
```

But still we can bypass this by matching this regex, and still going outside the directory.

For example: `index.php?language=./languages/../../../../etc/passwd`.

### Appended Extension

With modern versions of PHP, we can't bypass this, but still we can read files with that extension, for example for reading the source code.

#### Path Truncuation

In older versions of PHP strings had a max length of 4096 characters, because of the 32-bit systems.

If longer string is passed, it would be `truncated` and anything after the max would be ignored.

PHP also used to remove dots and trailing slashes so calling `/etc/passwd/.` the `/.` would be truncated.

In both Linux and PHP multiple slashes and a current directory `.` in the middle of the path would be ignored, so `////etc/./passwd` is the same as `/etc/passwd/`,

If we combine both of these we can create very long strings pointing to the correct path, and when we reach 4096 characters the appended `.php` extension would be truncated.

`?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]`

#### Null Bytes

PHP before 5.5 were vulnerabile to this. 

Meaning that adding a null byte `%00` would terminate the string and ignore everything after.

This is because of how strings are stored in low-level memory, where strings must use a null byte to indicate the end of the string (Assembly, C, C++).

So with `/etc/passwd%00` it would remove the appended extension `.php`

## PHP Filters

If an LFI vulnerbaility is discovered in PHP web apps, `PHP Wrappers` can be used to be able to extend the exploitation and maybe erach RCE.

`PHP Wrappers` allow us to  access different I/O streams at the app level, like the standard input/output, file descriptors, and memory streams.

This is also beneficial to other web attacks like **XXE**.

### Input Filters

Are a type of wrappers, where we can pass different types of input and filter it.

To use wrapper streams we begin with `php://` and we get access to the filter with `php://filter/`.

The main parameters of the `filter` wrapper:
- resource - specify the stream we would like to apply the filter (e.g. a local file).
- read - specify which filter we want to apply on the resource.

There are 3 types of filters:
- String
- Conversion
- Compression
- Encryption

For LFI attacks `convert.base64-encode` under the `Conversion Filters` is the one that will be used.

### Fuzzing for PHP Files

Fuzz for PHP pages:

```sh
ffuf -w /seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u server_ip:PORT/FUZZ.php
```

Also, files inside can reference some other `.php` files so, we have to check for that also.

### Standard PHP Inclusion

Sometimes when we want to read files through the LFI, the files are not shown, like for example `config.php` as it's most likely sets up the web app configurattion and odesn't render any HTML output.

But to read the source code, we have to use the `base64` filter, and we would get the encoded source code, instead of it being executed and rendered.

### Source Code Disclosure

When we got a list of PHP files that we want to read, we can use the `base-64` filter.

For example the `config.php` file:

```url
ip_address:PORT/index.php?language=php://filter/read=convert.base64-encode/resource=config
```


