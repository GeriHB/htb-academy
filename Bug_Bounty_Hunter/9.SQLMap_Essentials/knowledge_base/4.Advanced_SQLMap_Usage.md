# Advanced SQLMap Usage

## Bypassing Web Application Protections

Usually we expect problems when running an automated tool on the target, because of defense mechanisms.

But, SQLMap has also a number of mechanisms that can help to bypass these protections.

### Anti-CSRF Token Bypass

A usual defense mechanisms is the usage of **anti-CSRF** (Cross-Site Request Forgery) tokens into all HTTP headers - especially those generated as a result of web-form filling.

Each HTTP request should have a valid token available only if the user actually visited the used page - the original idea was to prevent the scenario with malicious links, when you just open it and have consequences for unaware logged-in users.

This also hardened the apps against the unwanted automation.

`--csrf-token` is the option of `sqlmap` to help bypassing the anti-CSRF protection.

`sqlmap` automatically then attempts to parse the target response content and search for fresh token values to be used in the next request.

Even if the token's name is not explicitly specified via `--csrf-token`, if one of the provided parameters contains any of the common (csrf, xsrf, token) `sqlmap` will prompt the user to update it in further requests.

### Unique Value Bytes

Sometimes we bapps requires unique values inside predefined parameters.

In contrast with `anti-CSRF` here there is no need to parse the web page content.

So, just by makins sure that each request has a unique value for this parameter, CSRF can be easily prevented, but also some of the automation tools.

SQLMap offers the option `--randomize` which should point to the parameter that contains the value which should be randomized.

```sh
sqlmap -u "http://www.example.com/?id=1&rp=29125" --randomize=rp --batch -v 5 | grep URI
```

### Calculated Parameter Bypass

Another mechanism is where a web app expects a proper parameter value to be calculated based on some other parameter values.

Usually one parameter value contains the message digest (e.g. h=MD5(id)) of another one.

SQLMap offers the option `--eval` where a valid Python code is evaluated just before the request is sent to the target.

```sh
sqlmap -u "http://www.example.com/?id=1&h=c4ca4238a0b923820dcc509a6f75849b" --eval="import hashlib; h=hashlib.md5(id).hexdigest()" --batch -v 5 | grep URI
```

### IP Address Concealing

Some web apps have a protection mechanisms to blacklist our current IP address, or we just want to hide our own.

So we can try to use a proxy or `Tor`.

It can be set via `--proxy`. We can add also a list of proxies `--proxy-file`.

If `Tor` is installed on the local machine, there should be a `SOCKS4` proxy service at the local port `9050 or 9150`, and by using `--tor` SQLMap tries to find the local port and use it.

If this works, beforehand we can check by `--check-tor`.

### WAF Bypass

During initial tests SQLMap sends some malicious lookin payloads to test for WAFs.

If there is any we should get a `406 - Not Acceptable`.

SQLMap tries to identify the mechanisms using the library `identYwaf` which has around 80 different WAF signatures, and if we want to skip this, to produce less noise we can use `--skip-waf`.

### User-agent Blacklisting Bypass

Sometimes we got problems as soon as we start, like for example getting a **HTTP error code 5XX**.

This can be because maybe there is a potential blacklisting of the default user-agent used by SQLMap.

We can bypass this with `--random-agent`, which chooses values from a large pool of values used by browsers.

### Tamper Scripts

One of the most popular mechanisms of SQLMap to bypass WAF/IPS is the `tamper` scripts.

Thery are scripts written in Python to modify the requests before they are sent to teh target.

`between` script replaces all `>` with `NOT BETWEEN 0 AND #`, and all `=` with `BETWEEN # AND #` - so primitive protection mechanisms to prevent XSS are bypassed.

We can put a number of tamper scripts `--tamper=between,randomcase` and they are run based on the priority.

List of all the tamper scripts can be seen by executing the option `--list-tampers`.

## Miscellaneous Bypasses

`--chunked` splits the POST body into `chkunks` and blacklisted keywords are split between chunks so they can pass unnoticed.

# OS Exploitation

Via SQL injection we can read and write files from the local system.

SQLMap even tries to give us RCE.

## File Read/Write

In MySQL t oread local files, the user must have the privilege to `LOAD DATA` and `INSERT` - load the content of a file to a table and read that table.

```sql
LOAD DATA LOCAL INFILE '/etc/passwd' INTO TABLE passwd;
```

If we have DBA privileges there is a high chance that we have file-read privileges.

This can be checked via `--is-dba` option.

Then to read files we can use `--file-read "/etc/passwd"`, which saves the file and then we can `cat` and read the content.

**Writing files** is much more restricted because this can provide us RCE.

In MySQL `--secure-file-priv` must be manually disabled to allow writing data into local files.

If this is the case we can use `--file-write` and `--file-dest` options.

```sh
sqlmap -u "http://www.example.com/?id=1" --file-write "shell.php" --file-dest "/var/www/html/shell.php"
```

## OS Command Execution

SQLMap can give us OS shell without writing a remote shell.

For this we can use `--os-shell`, but here the technique matters, so for example the `UNION` can fail to provide the output, so we can use the `Error-based SQL Injection`:

```sh
sqlmap -u "http://www.example.com/?id=1" --os-shell --technique=E
```


