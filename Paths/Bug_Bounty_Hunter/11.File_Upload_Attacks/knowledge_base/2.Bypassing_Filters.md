# Bypassing Filters

Many web apps rely on JS to validate the file format before being uploaded.

But, since it's happening on the client side, it's easy to bypass them by interacting with the server, skippiing the front-end validation.

This can be done also by modifying the front-end code by using the developer tools.

**Client-Side Validation**

Let's take an example where it doesn't allow us to upload a php shell, because it only accepts images.

But, we see that all the validation happens on the front-end, because the page **never refreshes or sends any HTTP requests after selecting the file**.

Since, any code on the client-side is under our control, the rendering and execution of the front-end code happens within the browser.

**Back-end Request Modification**

If we capture the upload request of a picture with Burp, we see two important parts:
- filename=HTB.png
- file content at the end of the request.

Now let's modify the filename to shell.php, and the content to the web shell.

If there is no validation on the backend, then this would go through.

Then visit the uploaded file and interact with it so we would get the RCE.

## Blacklist Filters

There are some web apps that have a blacklist of disallowed extensions in order to prevent uploading web scripts.

There are two ways this is achieved:
- Blacklist
- Whitelist

We can fuzz the upload functionality with a list of potential extensions and see which returns an error message.

We can do this via Burp Intruder.

Select the `.php` extension in the `filename="HTB.php` as the payload position. Put hte php extensions list on the `Payload Options`, and un-tick the URL Encoding, then start the attack.

## Whitelist Filters

Whitelist is more secure than Blacklist.

It allows only the specified extensions.

But also here there may be problems in the way that it has been coded. For example by using regex to check if the uploaded extension is part of a whitelist, it may only check whether the file name contains that extensions, and not if it actually ends with it.

So, it may allow also `shell.jpg.php`, because it sees that it contains the `.jpg` but in fact it is a `.php`.

**Reverse Double Extension**

Sometimes the **web server configuration** may lead to vulnerability.

For example `/etc/apache2/mods-enabled/php7.4.conf` may include the following configuration:

```xml
<FilesMatch ".+\.ph(ar|p|tml)">
    SetHandler application/x-httpd-php
</FilesMatch>
```

This configuration is how the web server determines which files to allow PHP code execution.

This regex specifies which files that contain the above extension will be allowed PHP code execution - even if it doesn't end with PHP extension, such as `shell.php.jpg`.

**Character Injection**

We can inject some characters before or after the final extension which will cause the web app to misinterpret the filename and execute the file as a PHP script:

```sh

%20
%0a
%00
%0d0a
/
.\
.
â€¦
:
```

These characters have a specific use case which tricks the web app to misinterpret the extension, for example `shell.php%00.jpg` works with PHP versions like `5.X` or earlier, and it causes the web server to end the file name after the `%00` and store it as `shell.php`.

